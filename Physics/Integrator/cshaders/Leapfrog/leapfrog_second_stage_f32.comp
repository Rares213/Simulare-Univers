// second stage of leapfrog algorithm
// computes v[i + 1] = v[i] + 0.5 * dt * (a[i] + a[i + 1])

#version 460 core

#define LOCAL_SIZE_X 64
layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 0) buffer ff_struct
{
	float dt;
};

layout(std430, binding = 1) buffer pos_x
{
	float x[];
};

layout(std430, binding = 2) buffer pos_y
{
	float y[];
};

layout(std430, binding = 3) buffer pos_z
{
	float z[];
};

///////////////VECLOCITY///////////////

layout(std430, binding = 4) buffer v_x
{
	float vx[];
};

layout(std430, binding = 5) buffer v_y
{
	float vy[];
};

layout(std430, binding = 6) buffer v_z
{
	float vz[];
};

///////////////ACCELERATION///////////////

layout(std430, binding = 7) buffer a_x
{
	float ax[];
};

layout(std430, binding = 8) buffer a_y
{
	float ay[];
};

layout(std430, binding = 9) buffer a_z
{
	float az[];
};

///////////////PREVIOUS_ACCELERATION///////////////

layout(std430, binding = 10) buffer prev_a_x
{
	float prev_ax[];
};

layout(std430, binding = 11) buffer prev_a_y
{
	float prev_ay[];
};

layout(std430, binding = 12) buffer prev_a_z
{
	float prev_az[];
};

void main()
{
	const uint id = gl_GlobalInvocationID.x;

	const float half_dt = 0.5 * dt;

	vx[id] = vx[id] + half_dt * (prev_ax[id] + ax[id]);
	vy[id] = vy[id] + half_dt * (prev_ay[id] + ay[id]);
	vz[id] = vz[id] + half_dt * (prev_az[id] + az[id]);
}