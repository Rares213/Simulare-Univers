// second stage of leapfrog algorithm
// computes v[i + 1] = v[i] + 0.5 * dt * (a[i] + a[i + 1])

#version 460 core

#define LOCAL_SIZE_X 64
layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 0) buffer ff_struct
{
	double dt;
};

layout(std430, binding = 1) buffer pos_x
{
	double x[];
};

layout(std430, binding = 2) buffer pos_y
{
	double y[];
};

layout(std430, binding = 3) buffer pos_z
{
	double z[];
};

///////////////VECLOCITY///////////////

layout(std430, binding = 4) buffer v_x
{
	double vx[];
};

layout(std430, binding = 5) buffer v_y
{
	double vy[];
};

layout(std430, binding = 6) buffer v_z
{
	double vz[];
};

///////////////ACCELERATION///////////////

layout(std430, binding = 7) buffer a_x
{
	double ax[];
};

layout(std430, binding = 8) buffer a_y
{
	double ay[];
};

layout(std430, binding = 9) buffer a_z
{
	double az[];
};

///////////////PREVIOUS_ACCELERATION///////////////

layout(std430, binding = 7) buffer prev_a_x
{
	double prev_ax[];
};

layout(std430, binding = 8) buffer prev_a_y
{
	double prev_ay[];
};

layout(std430, binding = 9) buffer prev_a_z
{
	double prev_az[];
};

void main()
{
	const uint id = gl_GlobalInvocationID.x;

	const double half_dt = 0.5 * dt;

	vx[id] = vx[id] + half_dt * (prev_ax[id] + ax[id]);
	vy[id] = vy[id] + half_dt * (prev_ay[id] + ay[id]);
	vz[id] = vz[id] + half_dt * (prev_az[id] + az[id]);
}